/*******************************************************************************
                                  iic.h
*******************************************************************************/
#ifndef _IIC_H
#define _IIC_H

#include "public.h"

// 定义IIC数据传输和个人引脚
sbit IIC_SCL=P2^1;    // IIC_SCL 定义为 P2.1，对应片上 I2C 总线的 SCL 线
sbit IIC_SDA=P2^0;    // IIC_SDA 定义为 P2.0，对应片上 I2C 总线的 SDA 线

// IIC 状态定义#define IIC_WRITE_MODE  0 // IIC写入模式标记
#define IIC_READ_MODE   1 // IIC读取模式的标记

// IIC 模块包含所有操作函数
void iic_start(void);        // 发送IIC开始信号，开始总线通信
void iic_stop(void);         // 发送IIC停止信号，结束当前从机的通信
void iic_write_byte(u8 txd); // IIC发送一个字节，将指定的数据写入I2C总线传输给从机
u8 iic_read_byte(u8 ack);    // IIC读取一个字节，从I2C总线读取一个字节数据，ack参数控制是否发送ACK信号
u8 iic_wait_ack(void);       // IIC等待ACK信号，用来检测从机应答的情况，必要时发送停止信号
void iic_ack(void);          // IIC发送ACK信号，恢复IIC常规通讯格式发送ACK让下一个	process
void iic_nack(void);         // 当向某个寄存器写入数据时，不返回读取值或进行连续写入操作，通常用于中断读取。



#endif /* _IIC_H */

/*******************************************************************************
                                  iic.c
*******************************************************************************/
#include "iic.h"               // 包含了I2C通信函数的定义的头文件

/*******************************************************************************
 * 函 数 名   : iic_start
 * 函 数 功 能: 产生 IIC 起始信号
 * 输    入   : 无
 * 输    出   : 无
 * 功能描述  : IIC起始信号是SDA先变低，然后SCL变高，再变低，通过延迟函数delay_10us控制时序
*******************************************************************************/
void iic_start(void)
{
    IIC_SDA = 1;                 // SDA置高电平，初始化SDA
    delay_10us(1);               // 10us延迟，等待线路稳定

    IIC_SCL = 1;                 // SCL置高电平，开始IIC时序    
		delay_10us(1);               // 10us延迟，等待线路稳定

    IIC_SDA = 0;                 // SDA置低电平，产生起始信号，SDA变低的同时SCL应当为高

    delay_10us(1);               // 10us延迟，确保SCL高期间SDA变为低

    IIC_SCL = 0;                 // SCL置低电平，我方准备发送数据（挂起总线）
    delay_10us(1);               // 10us延迟，确保SCL低期间，布置SCL、SDA线路状态正确
}

/*******************************************************************************
 * 函 数 名     : iic_stop
 * 函 数 功 能  : 产生 IIC 停止信号
 * 输    入     : 无
 * 输    出     : 无
 * 功能描述    : IIC停止信号是SCL先变高，然后SAD后变高，通过delay_10us控制时序
 ******************************************************************************/
void iic_stop(void)
{
    IIC_SDA = 0;          // SDA置低电平。先将SDA置低，为发出停止信号做准备
    delay_10us(1);        // 10us延迟，进行线路稳定化处理

    IIC_SCL = 1;          // SCL置高电平，标记开始停止信号流程
    
    delay_10us(1);        // 10us延迟，确保SCL高期间，SDA变为低
    
    IIC_SDA = 1;          // SDA由低变高，直接拉起停止信号，SCL保持为高
    
    delay_10us(1);        // 10us延迟，确保总线状态变化完全解除
}


/*******************************************************************************
 * 函 数 名     : iic_ack
 * 函 数 功 能  : 产生 ACK 应答信号
 * 输    入     : 无
 * 输    出     : 无
 * 功能描述    : ACK信号是控制SDA为低电平，需要保证SCL为高时SDA低电平，通过分步操作IIC_SCL、IIC_SDA进行时序控制 
******************************************************************************/
void iic_ack(void)
{
    IIC_SCL = 0;          // 首先保证 SCL 为低电平，使能 ACK 检测机制
    IIC_SDA = 0;          // SDA 设为低电平，表示正常的 ACK 应答

    delay_10us(1);        // 确保 I2C 总线线路状态改变被系统采样

    IIC_SCL = 1;          // 然后将 SCL 打开，允许 ACK 应答电路操作
    delay_10us(1);        // 给系统足够的检测时间

    IIC_SCL = 0;          // 最后 SCL 再次变为低电平，周期性的方波控制完成一个 ACK 应答周期
}


/*******************************************************************************
 * 函 数 名     : iic_nack
 * 函 数 功 能  : 产生 NACK (非应答) 信号
 * 输    入     : 无
 * 输    出     : 无
 * 功能描述    : NACK信号是控制SDA为高电平，需要保证SCL为高时SDA高电平，通过分步操作IIC_SCL、IIC_SDA进行时序控制
 ******************************************************************************/
void iic_nack(void)
{
    IIC_SCL = 0;          // 首先确保 SCL 为低电平，以使能 NACK 检测机制

    IIC_SDA = 1;          // SDA 设为高电平，表示产生 NACK（非应答）信号

    delay_10us(1);        // 等待系统采样 SDA 状态

    IIC_SCL = 1;          // 后将 SCL 打开，NACK 信号在 SCL 高电平时生效

    delay_10us(1);        // 确保 I2C 总线有足够的时间准备下一步操作

    IIC_SCL = 0;          // 最后 SCL 再次变为低电平，完成了一个NACK信号周期
}


/*******************************************************************************
 * 函 数 名 : iic_wait_ack
 * 函 数 功 能 : 等待应答信号到来
 * 输    入 : 无
 * 输    出 : 
 *               1, 未能接收到应答信号
 *               0, 成功接收到了应答信号
 * 功能描述  : 在器件间通信中，接收方需要回应应答信号，此函数用于等待接收方的应答信号，如果超出设定的时间，超时检测机制将触发 I2C 总线停止信号
 * 参数说明  : time_temp 用于计时判断接收等待时间是否过长，超过100单位时间则强制结束I2C通信，返回出错值1
 ******************************************************************************/
u8 iic_wait_ack(void)
{
    u8 time_temp = 0;          // 创建用于计时的计数器

    IIC_SCL = 1;               // 首先需要将 SCL 置位，这个时候任何应答信号只有生效
    delay_10us(1);             // 延迟确保信号被采样

    while(IIC_SCL)             // 此循环是为了等待 SDAL 由高变低的时间，SDAL的改变需要在SCL为高电平的时候发生
    {
        time_temp++;           // 递增计数器 time_temp
        if(time_temp>100)      // 考虑到传输时延和系统采样时间需求，若 time_temp 超过了一定的限制（假设 100），则认为通信可能失败  
        {
            iic_stop();        // 发送停止信号，释放总线
            return 1;          // 返回错误标志，表示应答接收失败
        }
    }

    IIC_SCL = 0;               // 将 SCL 屋为低电平进行状态恢复或者进行下一个操作

    return 0;                  // 返回正常的应答状态
}


/*******************************************************************************
 * 函 数 名  : iic_write_byte
 * 函 数 功 能: IIC 发送一个字节数据
 * 输    入  : dat 需要发送的字节数据
 * 输    出  : 无
 * 参数说明 : 
 * 地址位0 指明写(如果发送0则是写主设备地址)，
 * dat是指需要发送的字节信息
 * 该函数首先初始化总线IIC_SCL,然后循环8次，每次循环中对应位与DAT位比较，
 *匹配对应SDA板电平，之后将DAT左移一位，重复循环直至全部位发送完成，
 *发送每位总线信号维持时长为10us，每个周期总线信号上升沿确定数据位
 ******************************************************************************/
void iic_write_byte(u8 dat)
{
    u8 i = 0;               // 创建用于数据寄存器循环计数的变量i

    IIC_SCL = 0;            // 初始化 IIC_SCL 寄存器到低电平确保 I2C 通信正确开启

    for(i = 0; i < 8; i++)  // 循环将“dat”内的值转变为从机可理解的并行代码
    {  
        if((dat & 0x80) > 0) 
            IIC_SDA = 1;    // 如果位7为1, 拉SDA为高电平
        else 
            IIC_SDA = 0;    // 否则拉SDA为低电平
        dat <<= 1;          // 左移第一步数据位
        delay_10us(1);      // 10us时延确保SDA线电平变化被采样

        IIC_SCL = 1;        // SCL置高电平，确定datal线上的电平信号被锁住
        delay_10us(1); // 10us时延确保SCL电平变化被采样
        IIC_SCL = 0;        // SCL置低电平，完成一个数据位的传输到下一个位点
        delay_10us(1); // 10us时延确保线负载等效接地
    }
    delay_10us(1); // 在数据发送完成后，额外设置一次时延以确保SDA和SCL线的状态被正确采样
}



/*******************************************************************************
 * 函 数 名  : iic_read_byte
 * 函 数 功 能: IIC 读取一个字节数据
 * 输    入  : ack 指示是否发送ACK信号
 * 输    出  : 接收数据的字节信息
 * 参数说明 : ack 为0时, Slave 将第一个字节 ACK，之后的字节NACK;
 *            ack 为1时, 读取并发送 ACK （如果接收到ACK则正常读取下一个字节）
 *            IIC 寄存器首先置为低电平，循环遵循数据输出原则，为了取回8位数据，
 *            必须持有SCL在低电平，SDA的读取也是螺旋式，SDA线变化在SCL上升沿之前，
 *						在读取期间SCL置于高电平，以确保数据的一致性
 *            这意味着此函数通过IIC总线读取8位二进制数据后编码为整数（1byte）
 ******************************************************************************/
u8 iic_read_byte(u8 ack) 
{
    u8 i = 0, receive = 0;          // 创建用于数据寄存器循环计数的变量i，用于存储接收字节receive

    // 下面的循环是为了完成并行数据的串行传输回CPU实现读取Byte的数据操作
    for (i = 0; i < 8; i++)		 // 循环将“receive”的值转变成串行数据的并行代码
    {
        IIC_SCL = 0;                // IIC_SCL初始化在低电平使能信号的读取条件
        delay_10us(1);              // 确保SDA线路被正确采样
        IIC_SCL = 1;                // 将I2C总线置为高数，确保数据进入稳定状态

        receive <<= 1;              // 将数据左移以准备接收新数据位 
        if(IIC_SDA)receive++;        // SDAL上升，发现数据改变则在 receive 的最低位添加一个1
        delay_10us(1);              // 监听完成后，重置时钟为低电平，进行下一个数据位读取
    }

    if (!ack)                       // 如果ack为0，考虑可能的状况，按需使用ACK 1或 ACK 0
        iic_nack();                 // ACK数据缺失则Prim Slave发送NACK信号
    else
        iic_ack();                  // 此区为 ack 判断，未提及情况下默认为 ACK 受应状态
  
    return receive;                 // 将完成编译的数据返回给主函数位置调用
}

