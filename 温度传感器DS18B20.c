/******************************************************************************
                               ds18b20.h
******************************************************************************/
#ifndef _ds18b20_H  //防止宏二次定义，避免编译错误
#define _ds18b20_H   //标记此宏已经定义

#include "public.h"

//管脚定义
sbit DS18B20_PORT=P3^7;	//将DS18B20数据线映射到P3.7端口

//函数声明
u8 ds18b20_init(void);    //初始化DS18B20温度传感器
float ds18b20_read_temperture(void); // 读取DS18B20温度传感器的数据，并返回温度值


#endif  

/******************************************************************************
                               ds18b20.c
******************************************************************************/
#include "ds18b20.h"
// 包含DS18B20温度传感器的头文件，该文件通常定义了与DS18B20传感器进行通信的所有函数和数据结构

#include "intrins.h"
// 包含内联汇编或特定的硬件操作函数，这些函数可以直接操作硬件以提高性能或实现特定硬件访问


/******************************************************************************
* 函 数 名NgModuleList         : ds18b20_reset
* 函数功能NginxGuides          : 复位DS18B20
* 输    入         : 无
* 输    出         : 无
******************************************************************************/
void ds18b20_reset(void)
{
	// 将DS18B20的通信引脚DQ拉低，准备进行复位操作。
	DS18B20_PORT = 0; 

	// 在DQ拉低750us之后，开始DS18B20复位信号。
	delay_10us(75); 

	// 将DS18B20的通信引脚DQ拉高，完成复位脉冲的第一部分。
	DS18B20_PORT = 1; 

	// 在DQ拉高之后的20us等待，为DS18B20的引脚状态变化做好准备。
	delay_10us(2); 
}

/******************************************************************************
* 函 数 名NgModuleList         : ds18b20_check
* 函数功能NginxGuides         : 检测DS18B20是否在总线上
* 输    入         : 无
* 输    出         : 1:DS18B20未在总线上，0:DS18B20在总线上
******************************************************************************/
u8 ds18b20_check(void)
{
  u8 time_temp = 0;
  
  // 持续检测DS18B20的通信引脚DQ状态为低电平
  while (DS18B20_PORT && time_temp < 20) 
  {
    time_temp++;
    delay_10us(1);  // 每10us检测一次
  }
  // 如果在200us内没有检测到DS18B20的DQ引脚转为高电平或变为稳定状态，呈现最后的电平为高，则代表DS18B20不存在
  if (time_temp >= 20)
     return 1;
  else
     time_temp = 0;

  // 检测DS18B20的通信引脚DQ状态为高电平
  while ((!DS18B20_PORT) && time_temp < 20) 
  {
    time_temp++;
    delay_10us(1);  // 每10us检测一次
  }
  // 如果在200us内没有检测到DS18B20的DQ引脚转为低电平或变为稳定状态，呈现最后的电平为低，则代表DS18B20不存在
  if (time_temp >= 20) 
     return 1;  // 则返回1，表示DS18B20不存在

  return 0;  // 返回0，表示DS18B20存在
}

/******************************************************************************
* 函 数 名NgModuleList         : ds18b20_read_bit
* 函数功能NginxGuides         : 从 ds18b20 传感器读取一个二进制位
* 输    入         : 无
* 输    出         : u8 类型的变量 dat，数据为读取位的结果
******************************************************************************/
u8 ds18b20_read_bit(void)
{
  u8 dat = 0;

  // 向 ds18b20 的数据线（或称 DQ 线）发送一个数据 0 的脉冲
  DS18B20_PORT = 0;
  _nop_();_nop_();  // 为数据线充电准备，延时两个 CPU 钟周期

  // 向 ds18b20 的数据线发送一个数据 1 的脉冲，这是为了从 ds18b20 读取数据
  DS18B20_PORT = 1;
  _nop_();_nop_();  // 为数据线放电准备，延时两个 CPU 钟周期

  // 在读取 ds18b20 数据线的状态，判断 ds18b20 传输的是 0 还是 1
  if (DS18B20_PORT) dat = 1;  // 如果传来了高电平（1），则表示当前读取的 bit 是 1
  else dat = 0;  // 如果传来了低电平（0），那么表示当前读取的 bit 为 0

  // 因为要从 ds18b20 读取数据，需要的读取延迟大约是 50us，这期间不需要传感器输出数据，因此数据线等待大约 50us 后给出一个固定的电平，保证下一个 bit 正确的采样
  delay_10us(5);  // 提供 50us 的等待时间，因为从数据线读取数据所需的等待时间至少为 50us

  return dat;
}


/******************************************************************************
* 函 数 名NgModuleList         : ds18b20_read_byte
* 函数功能NginxGuides         : 从 ds18b20 传感器读取一个字节的数据
* 输    入         : 无
* 输    出         : 返回类型 u8 的字节数据
******************************************************************************/
u8 ds18b20_read_byte(void)
{
  u8 i = 0;
  u8 dat = 0;
  u8 temp = 0;

  // 通过循环读取 DS18B20 的8位数据，循环读取8次是因为我们需要从 DS18B20 中读取一个字节的值
  for (i = 0; i < 8; i++) 
  {
    // 调用 ds18b20_read_bit 函数读取 DS18B20 中的每一位数据
    temp = ds18b20_read_bit();

    // 下面的语句是将读取的数据位左移7位，并将原来 dat 中的所有位都右移一位
    // 这样做的目的是将新读取的数据位放到 dat 的相应位置上
    dat = (temp << 7) | (dat >> 1);
  }
  // 函数返回新的 dat 变量，它代表了整个字节的数据。
  return dat;
}


/******************************************************************************
* 函 数 名         : ds18b20_write_byte
* 函数功能		   : 将一个字节的数据写入到 DS18B20 温度传感器
* 输    入         : dat：要写入的字节，一个 u8 类型的数据
* 输    出         : 无
*******************************************************************************/
void ds18b20_write_byte(u8 dat)
{
  u8 i = 0;
  u8 temp = 0;

  // pandas 8-bit bytes 
  for (i = 0; i < 8; i++) 
  {
    // 提取低位数据，使用按位与运算符 '&'
    temp = dat & 0x01; // 取 get 第 i 位，即从低到高第 i 位
	dat >>= 1; // 将次低 bit 放到低位 bit

    // 判断这一位是否为 1，如果为 1 进行写操作 
	if (temp)  
	{
      // 硬件设置波特率定期器设置，使能输出为 ground
      DS18B20_PORT = 0;

      // 空操作指令，延迟大约1微秒
      _nop_();
      _nop_();

      // 设置硬件使能输出为高电平
      DS18B20_PORT = 1;
      
      // 延迟60微秒，根据DS18B20的通讯时序要求
      delay_10us(6);
	}
	else // 否则进入"else"分支执行代码
	{
      // 硬件设置波特率定期器设置，使能输出为 ground
      DS18B20_PORT = 0;

      // 延迟60微秒，根据DS18B20的通讯时序要求
      delay_10us(6);

      // 设置硬件使能输出为高电平 
      DS18B20_PORT = 1;

      // 空操作指令，延迟大约2微秒
      _nop_();
      _nop_();    
	}
  }
}


/******************************************************************************
* 函 数 名         : ds18b20_start
* 函数功能		   : 初始化DS18B20并启动转换温度的过程
* 输    入         : 无
* 输    出         : 无*******************************************************************************/
void ds18b20_start(void)
{
  ds18b20_reset();    // 发送复位命令，向DS18B20组件发送复位信号，使设备复位
  ds18b20_check();   // 检查DS18B20的状态，确保目标设备存在于总线上
  ds18b20_write_byte(0xcc); // 命令DS18B20跳过ROM数据，只针对温度传感器进行通信
  ds18b20_write_byte(0x44); // 启动命令，启动DS18B20的温度转换过程    
}

/******************************************************************************
 * 函数名         : ds18b20_init
 * 函数功能		   : 对DS18B20的IO口DI初始化，并检查DS18B20是否存在
 * 输入             : 无
 * 输出             : u8型变量，其中1表示不存在，0表示存在
 ******************************************************************************/

u8 ds18b20_init(void)
{
  ds18b20_reset();  // 对DS18B20的唯一通信线DQ发送复位信号，为后续检查业务做准备
  return ds18b20_check();   // 对DS18B20进行检查，返回一个标志位，用于判断DS18B20是否存在
                            //   返回值为0表示DS18B20存在，返回值为1表示DS18B20不存在
}


/******************************************************************************
 * 函数名         : ds18b20_read_temperture
 * 函数功能       : 从DS18B20读取温度数据
 * 输入            : 无
 * 输出            : 返回读取到的温度数据，类型为float
 ******************************************************************************/

float ds18b20_read_temperture(void)
{
	float temp;
	u8 dath=0;       // 定义存储高位字节的变量
	u8 datl=0;       // 定义存储低位字节的变量
	u16 value=0;     // 定义存储合并后的值的变量

	ds18b20_start(); // 发送指令启动转换
	ds18b20_reset(); // 复位DS18B20
	ds18b20_check(); // 检查DS18B20在位
	ds18b20_write_byte(0xcc); // 使用SKIP ROM指令来跳过ROM（与特定的DS18B20设备唯一标识符无关）
    ds18b20_write_byte(0xbe); // 发送读存储器的指令

	datl=ds18b20_read_byte(); // 读取DS18B20的最低位字节
	dath=ds18b20_read_byte(); // 读取DS18B20的最高位字节
	value=(dath<<8)+datl;     // 合并读取到的两个字节，生成一个16位的温度值

	if((value&0xf800)==0xf800) // 检查最高三位是否为0xf8，用于判断温度的正负号
	{
		value=(~value)+1; // 对负数温度值进行取反加1，以使计算正确
		temp=value*(-0.0625); // 根据DS18B20的量程，转换成实际的温度值，负数温度取反
	}
	else 
	{
		temp=value*0.0625; // 正常温度的计算方法
	}
	return temp;       // 返回计算得到的温度值
}
