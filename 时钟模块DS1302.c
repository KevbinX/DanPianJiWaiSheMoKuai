/*******************************************************************************
                        DS1302.H
*******************************************************************************/
#ifndef _ds1302_H
#define _ds1302_H

#include "public.h"

// 管脚定义
sbit DS1302_RST = P3^5;  // 定义复位管脚
sbit DS1302_CLK = P3^6;  // 定义时钟管脚
sbit DS1302_IO  = P3^4;  // 定义数据管脚

// 变量声明
extern u8 gDS1302_TIME[7];  // 存储时间的数组

// 函数声明
void ds1302_init(void);     // DS1302初始化函数声明
void ds1302_read_time(void);  // 读取DS1302时间函数声明

#endif
/*******************************************************************************
                        DS1302.c
*******************************************************************************/
#include "ds1302.h"
#include "intrins.h"

// DS1302写入和读取时分秒的地址命令
// 最低位为读写位，0：读；1：写
// 定义了两个字节数组，一个用于读取操作的地址，一个用于写入操作的地址。
u8 gREAD_RTC_ADDR[7] = {0x81, 0x83, 0x85, 0x87, 0x89, 0x8b, 0x8d}; 
u8 gWRITE_RTC_ADDR[7] = {0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c};

// DS1302时钟初始化日期和时间2021年5月20日星期四13点51分47秒
// 存储顺序为秒分时日月年周，存储格式为BCD码
// 这个数组用于存储时钟初始化时的时间和日期，使用BCD码格式存储。每四比特代表一位BCD码数字。
u8 gDS1302_TIME[7] = {0x47, 0x51, 0x13, 0x20, 0x04, 0x05, 0x21};

/*******************************************************************************
* 函 数 名       : ds1302_write_byte
* 函数功能		 : 使用DS1302 I2C通讯协议写入一个字节数据
* 输    入       : addr：地址/命令
				   dat：数据
* 输    出    	 : 无
* 注    解：
*      1. 单字节数据由8位组成；
*      2. 使用DS1302的硬件接口，初始化通讯，按照I2C主设备通信时序将地址和数据发送给DS1302；
*******************************************************************************/
void ds1302_write_byte(u8 addr,u8 dat)
{
	u8 i=0;
	
    // 释放复位信号(RST)，准备进行数据传输
	DS1302_RST=0;
	_nop_();	
    
    // 确保时钟信号(CLK)保持低电平，准备将RST拉高以开始写操作
	DS1302_CLK=0;
	_nop_();	
	
    // 将复位信号(RST)拉高，开始写过程
	DS1302_RST=1;
	_nop_();

    
    // 循环8次以发送整个字节，每次循环发送一位
	for(i=0;i<8;i++)// 循环8次，每次写1位，先写低位再写高位	
	{
        // 先移位获取当前位的值，使地址变为只有一位
        // Data指针向左移动一位，低位变为高位
		DS1302_IO=addr&0x01;
        // 移位运算后，改变数据方向的IP引脚状态，只写一次即可
		addr>>=1;
        // 将IO引脚拉高阻态，使电平由主设备发出
		DS1302_CLK=1;
		_nop_();
        // 再次变为低阻态，允许主设备改变IO引脚电平
		DS1302_CLK=0;
		_nop_();
	}
    
    // 再次循环8次将8位数据写入DS1302的指定存储位置
	for(i=0;i<8;i++)// 循环8次，每次写1位，先写低位再写高位	
	{
        // 先移位获取当前位的值，使数据变为只有一位
		DS1302_IO=dat&0x01;
        // 移位运算后，改变数据方向的IO引脚状态，只写一次即可
		dat>>=1;
        // 将IO引脚拉高阻态，使电平由主设备发出
		DS1302_CLK=1;
		_nop_();
        // 再次变为低阻态，允许主设备改变IO引脚电平
		DS1302_CLK=0;
		_nop_();
	}
    
    // 最后释放复位信号(RST)，结束数据传输周期
	DS1302_RST=0;//RST拉低
	_nop_();	
}


/*******************************************************************************
* 函 数 名       : ds1302_read_byte
* 函数功能		 : 通过DS1302读取单字节数据
* 输    入       : addr：地址/命令
* 输    出    	 : 读取到的数据
* 注    解：
*      1. 使用DS1302的硬件接口，初始化通讯，按照I2C主设备通信时序将地址发送给DS1302；
*      2. 首先通过写操作将地址与命令发送给DS1302，配合时钟信号的上升沿来实现数据传输到DS1302的一个内部寄存器中；
*      3. 然后通过读操作来实现从DS1302的数据寄存器读取需要的数据，这其中也需要配合时钟信号的上升沿调用；
*      4. 读取过程需要将读取到的数据通过位操作合并成一个字节，取出需要的数据。
*******************************************************************************/
u8 ds1302_read_byte(u8 addr)
{
	u8 i=0;
	u8 temp=0;
	u8 value=0;

    // 释放复位信号(RST)，准备进行数据传输
	DS1302_RST=0;
	_nop_();	

    // 确保时钟信号(CLK)保持低电平，准备将RST拉高，告诉DS1302我们需要开始读取过程
	DS1302_CLK=0;
	_nop_();	
	
    // 将复位信号(RST)拉高，开始读取操作
	DS1302_RST=1;
	_nop_();

    // 循环8次以发送整个字节，每次循环发送一位
	for(i=0;i<8;i++)// 循环8次，每次写1位，先写低位再写高位	
	{
        // 先移位获取当前位的值，使地址变为只有一位
        // Addr指针向左移动一位，低位变为高位
		DS1302_IO=addr&0x01;
        // 移位运算后，改变数据方向的IP引脚状态，仅写入一次即可，此处是重复了两次操作
		addr>>=1;
        // 将IO引脚拉高阻态，使电平由主设备发出
		DS1302_CLK=1;
		_nop_();	
        // 再次变为低阻态，允许主设备改变IO引脚电平
		DS1302_CLK=0;
		_nop_();
	}
    
    // 循环8次以读取整个字节，每次循环读取一位
	for(i=0;i<8;i++)// 循环8次，每次读1位，先读低位再读高位	
	{
        // 先判断当前的数据位的状态，保存为temp，改变数据方向的IO引脚状态
		temp=DS1302_IO;
        // 使用位操作重组数据，越位相左移7位，后移数据path右移一位，在边缘覆盖新写入的数据
		value=(temp<<7)|(value>>1);		
        // 将IO引脚拉高阻态，使电平由主设备发出
		DS1302_CLK=1;
		_nop_();
        // 再次变为低阻态，允许主设备改变IO引脚电平
		DS1302_CLK=0;
		_nop_();		
	}
    // 最后释放复位信号(RST)，结束数据传输周期
	DS1302_RST=0;//RST拉低
	_nop_();	
       
    // 在通讯过程中可能需要使CLK为高电平以产生上升沿或进行硬件操作
	DS1302_CLK=1;// 对于实物中，P3.4口没有外接上拉电阻的，此处代码需要添加，使数据口有一个上升沿脉冲。
	
	
    // 保证在读数据后恢复IO口反相高阻状态，释放DS1302的数据总线
	DS1302_IO = 0;
	_nop_();
	DS1302_IO = 1;
	_nop_();	
	return value;		
}


/*******************************************************************************
* 函 数 名       : ds1302_init
* 函数功能		 : 初始化DS1302的时钟
* 输    入       : 无
* 输    出    	 : 无
* 注    解：
*      1. 这个函数会首先将DS1302设为正常运行模式，通常DS1302需要启用24小时制和闹钟功能。我们在一开始初始化的时候会设置这些配置，包括确认闹钟闹铃中断端口状态为0，即没有闹铃触发；
*      2. 紧接着，使用for循环构造，按照gWRITE_RTC_ADDR中定义的地址序列，从低位(B秒)开始向高位(Y年)写入gDS1302_TIME中定义的时间和日期数据；
*      3. 需要注意，这里有防范万一同步不准确的问题，还未进行寄存器的同步确认，因此将C1H这一寄存器设置成0x80来控制DS1302时钟；
*      4. 同样地，函数在执行完毕后除了应记录DS1302中时间已经设定完毕外，还要确认DS1302与主时钟之间已经完成对表并且实际写入的数据存储在正确的Register。
*******************************************************************************/
void ds1302_init()
{
    u8 i=0;
	ds1302_write_byte(0x8E,0X00);
	// 首先先设置一些初始状态，比如使得DS1302可以开始运行
    
	for(i=0;i<7;i++)
	{
		ds1302_write_byte(gWRITE_RTC_ADDR[i],gDS1302_TIME[i]);	
	}
    // 记录时钟的所有内容。
    // DS1302_TIME数组包含DS1302所需的全部内置时间格式信息

	ds1302_write_byte(0x8E,0X80);
    // 确定DS1302的存储空间和设备操作系统的一致
}


/*******************************************************************************
* 函 数 名       : ds1302_read_time
* 函数功能		 : DS1302读取时间
* 输    入       : 无
* 输    出    	 : 无
*******************************************************************************/
void ds1302_read_time(void)
{
    u8 i = 0;
	
    for(i = 0; i < 7; i++) // 循环7次，读取每个时钟寄存器的数据
    {
        gDS1302_TIME[i] = ds1302_read_byte(gREAD_RTC_ADDR[i]); // 通过读取指定地址来获取时钟数据
    }	
}
